//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// DO NOT EDIT THIS FILE!!!
// The file is auto-generated by build.py
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#include <emscripten.h>
#include <blst.hpp>
using namespace blst;
#pragma GCC diagnostic ignored "-Wreturn-stack-address"
extern "C" {

EM_JS(void, blst_exception, (BLST_ERROR code), {
    throw new Error(BLST_ERROR_str[code]);
});

const P1_Affine* EMSCRIPTEN_KEEPALIVE const_G1()
{   return reinterpret_cast<const P1_Affine*>(&BLS12_381_G1);   }
const P2_Affine* EMSCRIPTEN_KEEPALIVE const_G2()
{   return reinterpret_cast<const P2_Affine*>(&BLS12_381_G2);   }
const P1_Affine* EMSCRIPTEN_KEEPALIVE const_NEG_G1()
{   return reinterpret_cast<const P1_Affine*>(&BLS12_381_NEG_G1);   }
const P2_Affine* EMSCRIPTEN_KEEPALIVE const_NEG_G2()
{   return reinterpret_cast<const P2_Affine*>(&BLS12_381_NEG_G2);   }

SecretKey* EMSCRIPTEN_KEEPALIVE SecretKey_0()
{   return new SecretKey();   }
void EMSCRIPTEN_KEEPALIVE SecretKey__destroy__0(SecretKey* self)
{   explicit_bzero((void*)self, sizeof(*self)); delete self;   }

void EMSCRIPTEN_KEEPALIVE SecretKey_keygen_3(SecretKey* self, const byte* IKM, size_t IKM_len, const char* info)
{   self->keygen(IKM, IKM_len, info ? info : "");   }

void EMSCRIPTEN_KEEPALIVE SecretKey_derive_master_eip2333_2(SecretKey* self, const byte* IKM, size_t IKM_len)
{   self->derive_master_eip2333(IKM, IKM_len);   }

void EMSCRIPTEN_KEEPALIVE SecretKey_derive_child_eip2333_2(SecretKey* self, const SecretKey* sk, unsigned int child_index)
{   self->derive_child_eip2333(*sk, child_index);   }

void EMSCRIPTEN_KEEPALIVE SecretKey_from_bendian_1(SecretKey* self, const byte* sk)
{   self->from_bendian(sk);   }

void EMSCRIPTEN_KEEPALIVE SecretKey_from_lendian_1(SecretKey* self, const byte* sk)
{   self->from_lendian(sk);   }

byte* EMSCRIPTEN_KEEPALIVE SecretKey_to_bendian_0(const SecretKey* self)
{   byte out[32];
    self->to_bendian(out);
    return out;
}

byte* EMSCRIPTEN_KEEPALIVE SecretKey_to_lendian_0(const SecretKey* self)
{   byte out[32];
    self->to_lendian(out);
    return out;
}

Scalar* EMSCRIPTEN_KEEPALIVE Scalar_0()
{   return new Scalar();   }
Scalar* EMSCRIPTEN_KEEPALIVE Scalar_2(const byte* scalar, size_t nbits)
{   return new Scalar(scalar, nbits);   }
Scalar* EMSCRIPTEN_KEEPALIVE Scalar_3(const byte* msg, size_t msg_len, const char* DST)
{   return new Scalar(msg, msg_len, DST ? DST : "");   }
void EMSCRIPTEN_KEEPALIVE Scalar__destroy__0(Scalar* self)
{   delete self;   }

void EMSCRIPTEN_KEEPALIVE Scalar_hash_to_3(Scalar* self, const byte* msg, size_t msg_len, const char* DST)
{   (void)self->hash_to(msg, msg_len, DST ? DST : "");   }

Scalar* EMSCRIPTEN_KEEPALIVE Scalar_dup_0(const Scalar* self)
{   return new Scalar(self->dup());   }

void EMSCRIPTEN_KEEPALIVE Scalar_from_bendian_2(Scalar* self, const byte* msg, size_t msg_len)
{   (void)self->from_bendian(msg, msg_len);   }

void EMSCRIPTEN_KEEPALIVE Scalar_from_lendian_2(Scalar* self, const byte* msg, size_t msg_len)
{   (void)self->from_lendian(msg, msg_len);   }

byte* EMSCRIPTEN_KEEPALIVE Scalar_to_bendian_0(const Scalar* self)
{   byte out[32];
    self->to_bendian(out);
    return out;
}

byte* EMSCRIPTEN_KEEPALIVE Scalar_to_lendian_0(const Scalar* self)
{   byte out[32];
    self->to_lendian(out);
    return out;
}

void EMSCRIPTEN_KEEPALIVE Scalar_add_1(Scalar* self, const Scalar* a)
{   try                         { (void)self->add(*a); }
    catch (const BLST_ERROR& e) { blst_exception(e);   }
}

void EMSCRIPTEN_KEEPALIVE Scalar_sub_1(Scalar* self, const Scalar* a)
{   try                         { (void)self->sub(*a); }
    catch (const BLST_ERROR& e) { blst_exception(e);   }
}

void EMSCRIPTEN_KEEPALIVE Scalar_mul_1(Scalar* self, const Scalar* a)
{   try                         { (void)self->mul(*a); }
    catch (const BLST_ERROR& e) { blst_exception(e);   }
}

void EMSCRIPTEN_KEEPALIVE Scalar_inverse_0(Scalar* self)
{   (void)self->inverse();   }

PT* EMSCRIPTEN_KEEPALIVE PT_p_affine_1(const P1_Affine* p)
{   return new PT(*p);   }
PT* EMSCRIPTEN_KEEPALIVE PT_q_affine_1(const P2_Affine* q)
{   return new PT(*q);   }
PT* EMSCRIPTEN_KEEPALIVE PT_pq_affine_2(const P1_Affine* p, const P2_Affine* q)
{   return new PT(*p, *q);   }
PT* EMSCRIPTEN_KEEPALIVE PT_pq_2(const P1* p, const P2* q)
{   return new PT(*p, *q);   }
void EMSCRIPTEN_KEEPALIVE PT__destroy__0(PT* self)
{   delete self;   }

PT* EMSCRIPTEN_KEEPALIVE PT_dup_0(const PT* self)
{   return new PT(self->dup());   }

bool EMSCRIPTEN_KEEPALIVE PT_is_one_0(const PT* self)
{   return self->is_one();   }

bool EMSCRIPTEN_KEEPALIVE PT_is_equal_1(const PT* self, const PT* p)
{   return self->is_equal(*p);   }

void EMSCRIPTEN_KEEPALIVE PT_sqr_0(PT* self)
{   (void)self->sqr();   }

void EMSCRIPTEN_KEEPALIVE PT_mul_1(PT* self, const PT* p)
{   (void)self->mul(*p);   }

void EMSCRIPTEN_KEEPALIVE PT_final_exp_0(PT* self)
{   (void)self->final_exp();   }

bool EMSCRIPTEN_KEEPALIVE PT_in_group_0(const PT* self)
{   return self->in_group();   }

byte* EMSCRIPTEN_KEEPALIVE PT_to_bendian_0(const PT* self)
{   byte out[48*12];
    self->to_bendian(out);
    return out;
}

bool EMSCRIPTEN_KEEPALIVE PT_finalverify_2(const PT* gt1, const PT* gt2)
{   return PT::finalverify(*gt1, *gt2);   }

PT* EMSCRIPTEN_KEEPALIVE PT_one_0()
{   return new PT(PT::one());   }

Pairing* EMSCRIPTEN_KEEPALIVE Pairing_2(bool hash_or_encode, const char* DST)
{   return new Pairing(hash_or_encode, std::string{DST ? DST : ""});   }
void EMSCRIPTEN_KEEPALIVE Pairing__destroy__0(Pairing* self)
{   delete self;   }

void EMSCRIPTEN_KEEPALIVE Pairing_commit_0(Pairing* self)
{   self->commit();   }

size_t EMSCRIPTEN_KEEPALIVE Pairing_sizeof_0()
{   return blst_pairing_sizeof();   }

int EMSCRIPTEN_KEEPALIVE Pairing_merge_1(Pairing* self, const Pairing* ctx)
{   return self->merge(ctx);   }

bool EMSCRIPTEN_KEEPALIVE Pairing_finalverify_1(const Pairing* self, const PT* sig)
{   return self->finalverify(sig);   }

void EMSCRIPTEN_KEEPALIVE Pairing_raw_aggregate_2(Pairing* self, const P2_Affine* q, const P1_Affine* p)
{   self->raw_aggregate(q, p);   }

PT* EMSCRIPTEN_KEEPALIVE Pairing_as_fp12_0(Pairing* self)
{   return new PT(self->as_fp12());   }


P1_Affine* EMSCRIPTEN_KEEPALIVE P1_Affine_0()
{   return new P1_Affine();   }
P1_Affine* EMSCRIPTEN_KEEPALIVE P1_Affine_1(const P1* input)
{   return new P1_Affine(*input);   }
P1_Affine* EMSCRIPTEN_KEEPALIVE P1_Affine_2(const byte* input, size_t len)
{   try                         { return new P1_Affine(input, len); }
    catch (const BLST_ERROR& e) { blst_exception(e);                }
    return nullptr;
}
void EMSCRIPTEN_KEEPALIVE P1_Affine__destroy__0(P1_Affine* self)
{   delete self;   }

P1_Affine* EMSCRIPTEN_KEEPALIVE P1_Affine_dup_0(const P1_Affine* self)
{   return new P1_Affine(self->dup());   }

P1* EMSCRIPTEN_KEEPALIVE P1_Affine_to_jacobian_0(const P1_Affine* self)
{   return new P1(self->to_jacobian());   }

byte* EMSCRIPTEN_KEEPALIVE P1_Affine_serialize_0(const P1_Affine* self)
{   byte out[96*1];
    self->serialize(out);
    return out;
}

byte* EMSCRIPTEN_KEEPALIVE P1_Affine_compress_0(const P1_Affine* self)
{   byte out[48*1];
    self->compress(out);
    return out;
}

bool EMSCRIPTEN_KEEPALIVE P1_Affine_on_curve_0(const P1_Affine* self)
{   return self->on_curve();   }

bool EMSCRIPTEN_KEEPALIVE P1_Affine_in_group_0(const P1_Affine* self)
{   return self->in_group();   }

bool EMSCRIPTEN_KEEPALIVE P1_Affine_is_inf_0(const P1_Affine* self)
{   return self->is_inf();   }

bool EMSCRIPTEN_KEEPALIVE P1_Affine_is_equal_1(const P1_Affine* self, const P1_Affine* p)
{   return self->is_equal(*p);   }

int EMSCRIPTEN_KEEPALIVE P1_Affine_core_verify_7(const P1_Affine* self,
                                const P2_Affine* pk, bool hash_or_encode,
                                const byte* msg, size_t msg_len,
                                const char* DST,
                                const byte* aug, size_t aug_len)
{ return self->core_verify(*pk, hash_or_encode, msg, msg_len, DST ? DST : "", aug, aug_len); }

P1_Affine* EMSCRIPTEN_KEEPALIVE P1_Affine_generator_0()
{   return new P1_Affine(P1_Affine::generator());   }

P1* EMSCRIPTEN_KEEPALIVE P1_0()
{   return new P1();   }
P1* EMSCRIPTEN_KEEPALIVE P1_affine_1(const P1_Affine* p)
{   return new P1(*p);   }
P1* EMSCRIPTEN_KEEPALIVE P1_secretkey_1(const SecretKey* sk)
{   return new P1(*sk);   }
P1* EMSCRIPTEN_KEEPALIVE P1_2(const byte* input, size_t len)
{   try                         { return new P1(input, len); }
    catch (const BLST_ERROR& e) { blst_exception(e);         }
    return nullptr;
}
void EMSCRIPTEN_KEEPALIVE P1__destroy__0(P1* self)
{   delete self;   }

P1* EMSCRIPTEN_KEEPALIVE P1_dup_0(const P1* self)
{   return new P1(self->dup());   }

P1* EMSCRIPTEN_KEEPALIVE P1_to_affine_0(const P1* self)
{   return new P1(self->to_affine());   }

byte* EMSCRIPTEN_KEEPALIVE P1_serialize_0(const P1* self)
{   byte out[96*1];
    self->serialize(out);
    return out;
}

byte* EMSCRIPTEN_KEEPALIVE P1_compress_0(const P1* self)
{   byte out[48*1];
    self->compress(out);
    return out;
}

bool EMSCRIPTEN_KEEPALIVE P1_on_curve_0(const P1* self)
{   return self->on_curve();   }

bool EMSCRIPTEN_KEEPALIVE P1_in_group_0(const P1* self)
{   return self->in_group();   }

bool EMSCRIPTEN_KEEPALIVE P1_is_inf_0(const P1* self)
{   return self->is_inf();   }

bool EMSCRIPTEN_KEEPALIVE P1_is_equal_1(const P1* self, const P1* p)
{   return self->is_equal(*p);   }

void EMSCRIPTEN_KEEPALIVE P1_aggregate_1(P1* self, const P1_Affine* p)
{   try                         { self->aggregate(*p); }
    catch (const BLST_ERROR& e) { blst_exception(e);   }
}

void EMSCRIPTEN_KEEPALIVE P1_sign_with_1(P1* self, const SecretKey* sk)
{   (void)self->sign_with(*sk);   }

void EMSCRIPTEN_KEEPALIVE P1_hash_to_5(P1* self, const byte* msg, size_t msg_len,
                                                 const char* DST,
                                                 const byte* aug, size_t aug_len)
{   (void)self->hash_to(msg, msg_len, DST ? DST : "", aug, aug_len);   }

void EMSCRIPTEN_KEEPALIVE P1_encode_to_5(P1* self, const byte* msg, size_t msg_len,
                                                   const char* DST,
                                                   const byte* aug, size_t aug_len)
{   (void)self->encode_to(msg, msg_len, DST ? DST : "", aug, aug_len);   }

void EMSCRIPTEN_KEEPALIVE P1_mult_1(P1* self, const Scalar* scalar)
{   (void)self->mult(*scalar);   }
void EMSCRIPTEN_KEEPALIVE P1_mult_2(P1* self, const byte* scalar, size_t nbits)
{   (void)self->mult(scalar, nbits);   }

void EMSCRIPTEN_KEEPALIVE P1_cneg_1(P1* self, bool flag)
{   (void)self->cneg(flag);   }

void EMSCRIPTEN_KEEPALIVE P1_add_1(P1* self, const P1* a)
{   (void)self->add(*a);   }
void EMSCRIPTEN_KEEPALIVE P1_add_affine_1(P1* self, const P1_Affine* a)
{   (void)self->add(*a);   }

void EMSCRIPTEN_KEEPALIVE P1_dbl_0(P1* self)
{   (void)self->dbl();   }

P1* EMSCRIPTEN_KEEPALIVE P1_generator_0()
{   return new P1(P1::generator());   }

int EMSCRIPTEN_KEEPALIVE Pairing_aggregate_pk_in_g1_6(Pairing* self,
                                const P1_Affine* pk, const P2_Affine* sig,
                                const byte* msg, size_t msg_len,
                                const byte* aug, size_t aug_len)
{   return self->aggregate(pk, sig, msg, msg_len, aug, aug_len);   }

int EMSCRIPTEN_KEEPALIVE Pairing_mul_n_aggregate_pk_in_g1_8(Pairing* self,
                                const P1_Affine* pk, const P2_Affine* sig,
                                const byte* scalar, size_t nbits,
                                const byte* msg, size_t msg_len,
                                const byte* aug, size_t aug_len)
{   return self->mul_n_aggregate(pk, sig, scalar, nbits, msg, msg_len, aug, aug_len);   }


P2_Affine* EMSCRIPTEN_KEEPALIVE P2_Affine_0()
{   return new P2_Affine();   }
P2_Affine* EMSCRIPTEN_KEEPALIVE P2_Affine_1(const P2* input)
{   return new P2_Affine(*input);   }
P2_Affine* EMSCRIPTEN_KEEPALIVE P2_Affine_2(const byte* input, size_t len)
{   try                         { return new P2_Affine(input, len); }
    catch (const BLST_ERROR& e) { blst_exception(e);                }
    return nullptr;
}
void EMSCRIPTEN_KEEPALIVE P2_Affine__destroy__0(P2_Affine* self)
{   delete self;   }

P2_Affine* EMSCRIPTEN_KEEPALIVE P2_Affine_dup_0(const P2_Affine* self)
{   return new P2_Affine(self->dup());   }

P2* EMSCRIPTEN_KEEPALIVE P2_Affine_to_jacobian_0(const P2_Affine* self)
{   return new P2(self->to_jacobian());   }

byte* EMSCRIPTEN_KEEPALIVE P2_Affine_serialize_0(const P2_Affine* self)
{   byte out[96*2];
    self->serialize(out);
    return out;
}

byte* EMSCRIPTEN_KEEPALIVE P2_Affine_compress_0(const P2_Affine* self)
{   byte out[48*2];
    self->compress(out);
    return out;
}

bool EMSCRIPTEN_KEEPALIVE P2_Affine_on_curve_0(const P2_Affine* self)
{   return self->on_curve();   }

bool EMSCRIPTEN_KEEPALIVE P2_Affine_in_group_0(const P2_Affine* self)
{   return self->in_group();   }

bool EMSCRIPTEN_KEEPALIVE P2_Affine_is_inf_0(const P2_Affine* self)
{   return self->is_inf();   }

bool EMSCRIPTEN_KEEPALIVE P2_Affine_is_equal_1(const P2_Affine* self, const P2_Affine* p)
{   return self->is_equal(*p);   }

int EMSCRIPTEN_KEEPALIVE P2_Affine_core_verify_7(const P2_Affine* self,
                                const P1_Affine* pk, bool hash_or_encode,
                                const byte* msg, size_t msg_len,
                                const char* DST,
                                const byte* aug, size_t aug_len)
{ return self->core_verify(*pk, hash_or_encode, msg, msg_len, DST ? DST : "", aug, aug_len); }

P2_Affine* EMSCRIPTEN_KEEPALIVE P2_Affine_generator_0()
{   return new P2_Affine(P2_Affine::generator());   }

P2* EMSCRIPTEN_KEEPALIVE P2_0()
{   return new P2();   }
P2* EMSCRIPTEN_KEEPALIVE P2_affine_1(const P2_Affine* p)
{   return new P2(*p);   }
P2* EMSCRIPTEN_KEEPALIVE P2_secretkey_1(const SecretKey* sk)
{   return new P2(*sk);   }
P2* EMSCRIPTEN_KEEPALIVE P2_2(const byte* input, size_t len)
{   try                         { return new P2(input, len); }
    catch (const BLST_ERROR& e) { blst_exception(e);         }
    return nullptr;
}
void EMSCRIPTEN_KEEPALIVE P2__destroy__0(P2* self)
{   delete self;   }

P2* EMSCRIPTEN_KEEPALIVE P2_dup_0(const P2* self)
{   return new P2(self->dup());   }

P2* EMSCRIPTEN_KEEPALIVE P2_to_affine_0(const P2* self)
{   return new P2(self->to_affine());   }

byte* EMSCRIPTEN_KEEPALIVE P2_serialize_0(const P2* self)
{   byte out[96*2];
    self->serialize(out);
    return out;
}

byte* EMSCRIPTEN_KEEPALIVE P2_compress_0(const P2* self)
{   byte out[48*2];
    self->compress(out);
    return out;
}

bool EMSCRIPTEN_KEEPALIVE P2_on_curve_0(const P2* self)
{   return self->on_curve();   }

bool EMSCRIPTEN_KEEPALIVE P2_in_group_0(const P2* self)
{   return self->in_group();   }

bool EMSCRIPTEN_KEEPALIVE P2_is_inf_0(const P2* self)
{   return self->is_inf();   }

bool EMSCRIPTEN_KEEPALIVE P2_is_equal_1(const P2* self, const P2* p)
{   return self->is_equal(*p);   }

void EMSCRIPTEN_KEEPALIVE P2_aggregate_1(P2* self, const P2_Affine* p)
{   try                         { self->aggregate(*p); }
    catch (const BLST_ERROR& e) { blst_exception(e);   }
}

void EMSCRIPTEN_KEEPALIVE P2_sign_with_1(P2* self, const SecretKey* sk)
{   (void)self->sign_with(*sk);   }

void EMSCRIPTEN_KEEPALIVE P2_hash_to_5(P2* self, const byte* msg, size_t msg_len,
                                                 const char* DST,
                                                 const byte* aug, size_t aug_len)
{   (void)self->hash_to(msg, msg_len, DST ? DST : "", aug, aug_len);   }

void EMSCRIPTEN_KEEPALIVE P2_encode_to_5(P2* self, const byte* msg, size_t msg_len,
                                                   const char* DST,
                                                   const byte* aug, size_t aug_len)
{   (void)self->encode_to(msg, msg_len, DST ? DST : "", aug, aug_len);   }

void EMSCRIPTEN_KEEPALIVE P2_mult_1(P2* self, const Scalar* scalar)
{   (void)self->mult(*scalar);   }
void EMSCRIPTEN_KEEPALIVE P2_mult_2(P2* self, const byte* scalar, size_t nbits)
{   (void)self->mult(scalar, nbits);   }

void EMSCRIPTEN_KEEPALIVE P2_cneg_1(P2* self, bool flag)
{   (void)self->cneg(flag);   }

void EMSCRIPTEN_KEEPALIVE P2_add_1(P2* self, const P2* a)
{   (void)self->add(*a);   }
void EMSCRIPTEN_KEEPALIVE P2_add_affine_1(P2* self, const P2_Affine* a)
{   (void)self->add(*a);   }

void EMSCRIPTEN_KEEPALIVE P2_dbl_0(P2* self)
{   (void)self->dbl();   }

P2* EMSCRIPTEN_KEEPALIVE P2_generator_0()
{   return new P2(P2::generator());   }

int EMSCRIPTEN_KEEPALIVE Pairing_aggregate_pk_in_g2_6(Pairing* self,
                                const P2_Affine* pk, const P1_Affine* sig,
                                const byte* msg, size_t msg_len,
                                const byte* aug, size_t aug_len)
{   return self->aggregate(pk, sig, msg, msg_len, aug, aug_len);   }

int EMSCRIPTEN_KEEPALIVE Pairing_mul_n_aggregate_pk_in_g2_8(Pairing* self,
                                const P2_Affine* pk, const P1_Affine* sig,
                                const byte* scalar, size_t nbits,
                                const byte* msg, size_t msg_len,
                                const byte* aug, size_t aug_len)
{   return self->mul_n_aggregate(pk, sig, scalar, nbits, msg, msg_len, aug, aug_len);   }

}
